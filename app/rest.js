// Generated by CoffeeScript 1.6.2
var PREFIX, add_type, arg_map, async, die_on_error, fail_on_error, get_json, redis, set_json, types, _, _ref, _ref1;

_ = require('underscore');

async = require('async');

_ref = require('./persist'), set_json = _ref.set_json, get_json = _ref.get_json, redis = _ref.redis;

_ref1 = require('./util'), arg_map = _ref1.arg_map, fail_on_error = _ref1.fail_on_error, die_on_error = _ref1.die_on_error;

PREFIX = "short";

types = {};

add_type = function(app, type, _arg) {
  var add, after_add, after_get, before_del, count, del, get, get_all, get_collection, get_range, load_child_list, load_child_set, save, type_dict, _ref2;

  _ref2 = _arg != null ? _arg : {}, after_add = _ref2.after_add, before_del = _ref2.before_del, after_get = _ref2.after_get;
  if (after_add == null) {
    after_add = function(model, callback) {
      return callback();
    };
  }
  if (before_del == null) {
    before_del = function(model, callback) {
      return callback();
    };
  }
  if (after_get == null) {
    after_get = function(model, callback) {
      return callback(null, model);
    };
  }
  add = function(data, callback) {
    var write;

    write = function() {
      return set_json("" + PREFIX + ":" + type + "s:" + data.id, data, fail_on_error(callback, function() {
        return redis.rpush("" + PREFIX + ":" + type + "s", data.id, fail_on_error(callback, function() {
          return after_add(data, fail_on_error(callback, function() {
            return callback(null, data);
          }));
        }));
      }));
    };
    if (data.id != null) {
      return write(data);
    } else {
      return redis.incr("" + PREFIX + ":" + type + "_count", fail_on_error(callback, function(id) {
        data.id = "" + id;
        return write(data);
      }));
    }
  };
  save = function(data, callback) {
    var key;

    console.log('Save!');
    if (data.id == null) {
      console.log('No id!');
      return add(data, callback);
    } else {
      key = "" + PREFIX + ":" + type + "s:" + data.id;
      return redis.get(key, fail_on_error(callback, function(previous) {
        console.log(previous);
        if (previous != null) {
          return set_json(key, data, callback);
        } else {
          console.log('No previous!');
          return add(data, callback);
        }
      }));
    }
  };
  del = function(id, callback) {
    return get(id, fail_on_error(callback, function(model) {
      return before_del(model, fail_on_error(callback, function() {
        redis.del("" + PREFIX + ":" + type + "s:" + id);
        return redis.lrem("" + PREFIX + ":" + type + "s", 0, id, callback);
      }));
    }));
  };
  get = function(id, callback) {
    return get_json("" + PREFIX + ":" + type + "s:" + id, fail_on_error(callback, function(data) {
      if (data != null) {
        console.log("" + PREFIX + ":" + type + "s:" + id);
        return after_get(data, callback);
      } else {
        return callback("No such users " + id);
      }
    }));
  };
  get_collection = function(ids, callback) {
    if (ids == null) {
      ids = [];
    }
    return arg_map(async.map, 'array', 'iterator', 'callback', {
      array: ids,
      iterator: get,
      callback: callback
    });
  };
  get_all = function(callback) {
    return get_range(0, -1, callback);
  };
  get_range = function(start, end, callback) {
    return redis.lrange("" + PREFIX + ":" + type + "s", start, end, fail_on_error(callback, function(model_ids) {
      return get_collection(model_ids, callback);
    }));
  };
  count = function(callback) {
    return redis.llen("" + PREFIX + ":" + type + "s", callback);
  };
  load_child_list = function(model, child, child_type, callback) {
    return redis.lrange("" + PREFIX + ":" + type + "s:" + model.id + ":" + child, 0, -1, fail_on_error(callback, function(child_ids) {
      return child_type.get_collection(child_ids, fail_on_error(callback, function(children) {
        model[child] = children;
        return callback(null, model);
      }));
    }));
  };
  load_child_set = function(model, child, child_type, callback) {
    return redis.smembers("" + PREFIX + ":" + type + "s:" + model.id + ":" + child, fail_on_error(callback, function(child_ids) {
      return child_type.get_collection(child_ids, fail_on_error(callback, function(children) {
        model[child] = children;
        return callback(null, model);
      }));
    }));
  };
  app.post("/" + type + "s", function(req, res) {
    return add(JSON.parse(req.body.json), die_on_error(res, function(model) {
      return res.send(200, JSON.stringify(model));
    }));
  });
  app.get("/" + type + "s.json", function(req, res) {
    return get_all(die_on_error(res, function(models) {
      return res.send(200, JSON.stringify(models));
    }));
  });
  app.get("/" + type + "s", function(req, res) {
    return get_all(die_on_error(res, function(models) {
      return res.send(200, JSON.stringify(models));
    }));
  });
  app.get("/" + type + "s/range/:start::end", function(req, res) {
    var end, start;

    start = parseInt(req.params.start);
    end = parseInt(req.params.end);
    return get_range(start, end, die_on_error(res, function(models) {
      return res.send(200, JSON.stringify(models));
    }));
  });
  app.get("/" + type + "s/count", function(req, res) {
    return count(die_on_error(req, function(count) {
      return res.send(200, "" + count);
    }));
  });
  app.get("/" + type + "/:id", function(req, res) {
    var id;

    id = req.params.id;
    return get(id, die_on_error(res, function(models) {
      return res.send(200, JSON.stringify(models));
    }));
  });
  app["delete"]("/" + type + "/:id", function(req, res) {
    var id;

    id = req.params.id;
    return del(id, die_on_error(res, function(removed) {
      return res.send(200, removed);
    }));
  });
  app.post("/" + type + "/:id", function(req, res) {
    var model;

    model = JSON.parse(req.body.json);
    model.id = req.params.id;
    console.log('Saving with id...');
    return save(model, die_on_error(res, function(saved) {
      return res.send(200, saved);
    }));
  });
  type_dict = {
    add: add,
    save: save,
    del: del,
    get: get,
    get_collection: get_collection,
    count: count,
    load_child_list: load_child_list,
    get_all: get_all,
    get_range: get_range,
    load_child_set: load_child_set
  };
  types[type] = type_dict;
  return type_dict;
};

module.exports = {
  add_type: add_type,
  types: types,
  PREFIX: PREFIX
};
